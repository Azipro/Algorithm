算法特点：

迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法
的一个子模块。

算法的思路

Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，
原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）
顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 
然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 
然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点
在dis中的值。 
然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。


有<v1, v6> = 100
    <v1, v5> = 30
    <v1, v3> = 10
    <v2, v3> = 5
    <v3, v4> = 50
    <v4, v6> = 10
    <v5, v6> = 60
    <v5, v4> = 20
开始顶点集合T = {v1}
初始化数组dis为(v1到个顶点的长度),然后找出数值最小且不在T内的顶点，加入T中，并更新dis为dis[i] = min(dis[j] + dis[i], dis[i])

模拟：
dis    v1    v2    v3   v4   v5    v6
         0     ∞     10    ∞    30   100   T={v1}
         0     ∞     10   60   30   100   T={v1,v3}
         0     ∞     10   50   30   90     T={v1,v3,v5}
         0     ∞     10   50   30   60     T={v1,v3,v5,v4}
         0     ∞     10   50   30   60 T={v1,v3,v5,v4,v6}


代码：
	memset(r, 62, sizeof(r));
        for(int i = 1; i <= n; i++) {
            r[i][i] = 0;
        }
        while(m--) {
            cin >> a >> b >> c;
            r[a][b] = r[b][a] = min(r[a][b], c);
        }
        int ans = dijkstra(1);


int dijkstra(int x) {
    int dis[126], vis[126];
    memset(vis, 0, sizeof(vis));
    for(int i = 1; i <= n; i++) {
        dis[i] = r[i][x];
    }
    vis[x] = 1;
    for(int i = 1; i <= n; i++) {
        int v = 0, pos = INF;
        for(int j = 1; j <= n; j++) {
            if(!vis[j] && dis[j] < pos) {
                v = j;
               pos = dis[j];
            }
        }
        vis[v] = 1;
        for(int j = 1; j <= n; j++) {
            dis[j] = min(dis[j], dis[v] + r[v][j]);
        }
    }
    return dis[n];
}


Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算
有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。

1)算法思想原理：

     Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为
     这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）

      从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径
      的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置
      Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。

2).算法描述：

a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　

b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。

代码：
    	for(int i = 0 ; i < m ; i++){
    		scanf("%d %d %d", &x, &y, &w);
    		s[x][y] = min(s[x][y], w);
    		path[x][y] = -1;
    	}
    	for(int k = 1 ; k <= n ; k++){
    		for(int i = 1 ; i <= n ; i++){
    			for(int j = 1 ; j <= n ; j++){
    				if(s[i][j] > s[i][k] + s[k][j]){
    					s[i][j] = s[i][k] + s[k][j];
    					path[i][j] = k;
    				}
    			}	
    		}
    	}



每一步都尽可能小：
    	for(int k = 1 ; k <= n ; k++){
    		for(int i = 1 ; i <= n ; i++){
    			for(int j = 1 ; j <= n ; j++){
    				s[i][j] = min(max(s[i][k], s[k][j]), s[i][j]);
    			}	
    		}
    	}
