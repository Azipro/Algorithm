```
二分查找的基本思想是：    
设R[low..high]是当前的查找区间 
（1）首先确定该区间的中点位置：                   
（2）然后将待查的K值与R[mid].key比较：若相等，则查找成功并返回此位置，否则须确定新的查找区间，继续二分查找，
    具体方法如下：    
①  若R[mid].key>K，则由表的有序性可知R[mid..n].keys均大于K，因此若表中存在关键字等于K的结点，则该结点必定是在位置mid左边的
   子表R[1..mid-1]中，故新的查找区间是左子表R[1..mid-1]。    
②  若R[mid].key<K，则要查找的K必在mid的右子表R[mid+1..n]中，即新的查找区间是右子表R[mid+1..n]。下一次查找是针对新的查找区间进行的。    
   因此，从初始的查找区间R[1..n]开始，每经过一次与当前查找区间的中点位置上的结点关键字的比较，就可确定查找是否成功，不成功则当前的查找区间
   就缩小一半。这一过程重复直至找到关键字为K的结点，或者直至当前的查找区间为空(即查找失败)时为止。折半查找的时间复杂度为O(logn)，远远好于顺
   序查找的O(n)。



int Binary_Search(int a*,int n,int key)
{
    int low,high,mid;
    low=1;     /*定义最底下标为记录首位*/
    high=n;    /*定义最高下标为记录末位*/
    while(low<=high)
    {
        mid=(low+high)/2;    /*折半*/
        if(key<a[mid])
            high=mid-1;
        if(key>a[mid])
            low=mid+1;
        else
            return mid;
    }
    return 0;
}
```
